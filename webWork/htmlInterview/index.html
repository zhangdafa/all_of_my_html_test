<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>前端面试题</title>
</head>

<body>
    <h3>前端需要注意哪些seo</h3>
    <ol>
        <li>合理的title、description、keywords：搜索对着三项的权重逐个减小，title值强调重点即可，重要关键词出现不要超过2次，而且要靠前，不同页面title要有所不同；description把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面description有所不同；keywords列举出重要关键词即可</li>
        <li>语义化的HTML代码，符合W3C规范：语义化代码让搜索引擎容易理解网页</li>
        <li>重要内容HTML代码放在最前：搜索引擎抓取HTML顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容一定会被抓取</li>
        <li>重要内容不要用js输出：爬虫不会执行js获取内容</li>
        <li>少用iframe：搜索引擎不会抓取iframe中的内容</li>
        <li>非装饰性图片必须加alt</li>
        <li>提高网站速度：网站速度是搜索引擎排序的一个重要指标</li>
    </ol>
    <h3>web开发中会话跟踪的方法有哪些</h3>
    <ol>
        <li>cookie</li>
        <li>session</li>
        <li>url重写</li>
        <li>隐藏input</li>
        <li>ip地址</li>
    </ol>
    <h3>img的title和alt有什么区别</h3>
    <ol>
        <li>title是global attributes之一，用于为元素提供附加的advisory information。通常当鼠标滑动到元素上的时候显示。</li>
        <li>alt是img的特有属性，是图片内容的等价描述，用于图片无法加载时显示、读屏器阅读图片。可提图片高可访问性，除了纯装饰图片外都必须设置有意义的值，搜索引擎会重点分析。</li>
    </ol>
    <h3>doctype是什么举例常见doctype及特点</h3>
    <ol>
        <li>&lt;!doctype&gt;声明必须处于HTML文档的头部，在<code>&lt;html&gt;</code>标签之前，HTML5中不区分大小写</li>
        <li>&lt;!doctype&gt;声明不是一个HTML标签，是一个用于告诉浏览器当前HTMl版本的指令</li>
        <li>现代浏览器的html布局引擎通过检查doctype决定使用兼容模式还是标准模式对文档进行渲染，一些浏览器有一个接近标准模型。</li>
        <li>在HTML4.01中<code>&lt;!doctype&gt;</code>声明指向一个DTD，由于HTML4.01基于SGML，所以DTD指定了标记规则以保证浏览器正确渲染内容</li>
        <li>HTML5不基于SGML，所以不用指定DTD</li>
    </ol>
    <p>常见dotype：</p>
    <ol>
        <li><strong>HTML4.01 strict</strong>：不允许使用表现性、废弃元素（如font）以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt;</code></li>
        <li><strong>HTML4.01 Transitional</strong>:允许使用表现性、废弃元素（如font），不允许使用frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</code></li>
        <li><strong>HTML4.01 Frameset</strong>:允许表现性元素，废气元素以及frameset。声明：<code>&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" "http://www.w3.org/TR/html4/frameset.dtd"&gt;</code></li>
        <li><strong>XHTML1.0 Strict</strong>:不使用允许表现性、废弃元素以及frameset。文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</code></li>
        <li><strong>XHTML1.0 Transitional</strong>:允许使用表现性、废弃元素，不允许frameset，文档必须是结构良好的XMl文档。声明： <code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</code></li>
        <li><strong>XHTML 1.0 Frameset</strong>:允许使用表现性、废弃元素以及frameset，文档必须是结构良好的XML文档。声明：<code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;</code></li>
        <li><strong>HTML 5</strong>: <code>&lt;!doctype html&gt;</code></li>
    </ol>
    <h3>全局属性global-attribute有哪些</h3>
    <ul>
        <li><code>accesskey</code>:设置快捷键，提供快速访问元素如<a href="#" accesskey="a">aaa</a>在windows下的firefox中按<code>alt + shift + a</code>可激活元素</li>
        <li><code>class</code>:为元素设置类标识，多个类名用空格分开，CSS和javascript可通过class属性获取元素</li>
        <li><code>contenteditable</code>: 指定元素内容是否可编辑</li>
        <li><code>contextmenu</code>: 自定义鼠标右键弹出菜单内容</li>
        <li><code>data-*</code>: 为元素增加自定义属性</li>
        <li><code>dir</code>: 设置元素文本方向</li>
        <li><code>draggable</code>: 设置元素是否可拖拽</li>
        <li><code>dropzone</code>: 设置元素拖放类型： copy, move, link</li>
        <li><code>hidden</code>: 表示一个元素是否与文档。样式上会导致元素不显示，但是不能用这个属性实现样式效果</li>
        <li><code>id</code>: 元素id，文档内唯一</li>
        <li><code>lang</code>: 元素内容的的语言</li>
        <li><code>spellcheck</code>: 是否启动拼写和语法检查</li>
        <li><code>style</code>: 行内css样式</li>
        <li><code>tabindex</code>: 设置元素可以获得焦点，通过tab可以导航</li>
        <li><code>title</code>: 元素相关的建议信息</li>
        <li><code>translate</code>: 元素和子孙节点内容是否需要本地化</li>
    </ul>
    <h3>什么是web语义化有什么好处</h3>
    <p>web语义化是指通过HTML标记表示页面包含的信息，包含了HTML标签的语义化和css命名的语义化。 HTML标签的语义化是指：通过使用包含语义的标签（如h1-h6）恰当地表示文档结构 css命名的语义化是指：为html标签添加有意义的class，id补充未表达的语义，如
        <a href="http://en.wikipedia.org/wiki/Microformats">Microformat</a>通过添加符合规则的class描述信息 为什么需要语义化：
    </p>
    <ul>
        <li>去掉样式后页面呈现清晰的结构</li>
        <li>盲人使用读屏器更好地阅读</li>
        <li>搜索引擎更好地理解页面，有利于收录</li>
        <li>便团队项目的可持续运作及维护</li>
    </ul>
    <h3>http-method</h3>
    <ol>
        <li>一台服务器要与HTTP1.1兼容，只要为资源实现<strong>GET</strong>和<strong>HEAD</strong>方法即可</li>
        <li><strong>GET</strong>是最常用的方法，通常用于<strong>请求服务器发送某个资源</strong>。</li>
        <li><strong>HEAD</strong>与GET类似，但<strong>服务器在响应中值返回首部，不返回实体的主体部分</strong></li>
        <li><strong>PUT</strong>让服务器<strong>用请求的主体部分来创建一个由所请求的URL命名的新文档，或者，如果那个URL已经存在的话，就用干这个主体替代它</strong></li>
        <li><strong>POST</strong>起初是用来向服务器输入数据的。实际上，通常会用它来支持HTML的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到要去的地方。</li>
        <li><strong>TRACE</strong>会在目的服务器端发起一个环回诊断，最后一站的服务器会弹回一个TRACE响应并在响应主体中携带它收到的原始请求报文。TRACE方法主要用于诊断，用于验证请求是否如愿穿过了请求/响应链。</li>
        <li><strong>OPTIONS</strong>方法请求web服务器告知其支持的各种功能。可以查询服务器支持哪些方法或者对某些特殊资源支持哪些方法。</li>
        <li><strong>DELETE</strong>请求服务器删除请求URL指定的资源</li>
    </ol>
    <h3>从浏览器地址栏输入url到显示页面的步骤以http为例</h3>
    <ol>
        <li>在浏览器地址栏输入URL</li>
        <li>浏览器查看<strong>缓存</strong>，如果请求资源在缓存中并且新鲜，跳转到转码步骤
            <ol>
                <li>如果资源未缓存，发起新请求</li>
                <li>如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。</li>
                <li>检验新鲜通常有两个HTTP头进行控制<code>Expires</code>和<code>Cache-Control</code>：
                    <ul>
                        <li>HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期</li>
                        <li>HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间</li>
                    </ul>
                </li>
            </ol>
        </li>
        <li>浏览器<strong>解析URL</strong>获取协议，主机，端口，path</li>
        <li>浏览器<strong>组装一个HTTP（GET）请求报文</strong></li>
        <li>浏览器<strong>获取主机ip地址</strong>，过程如下：
            <ol>
                <li>浏览器缓存</li>
                <li>本机缓存</li>
                <li>hosts文件</li>
                <li>路由器缓存</li>
                <li>ISP DNS缓存</li>
                <li>DNS递归查询（可能存在负载均衡导致每次IP不一样）</li>
            </ol>
        </li>
        <li><strong>打开一个socket与目标IP地址，端口建立TCP链接</strong>，三次握手如下：
            <ol>
                <li>客户端发送一个TCP的<strong>SYN=1，Seq=X</strong>的包到服务器端口</li>
                <li>服务器发回<strong>SYN=1， ACK=X+1， Seq=Y</strong>的响应包</li>
                <li>客户端发送<strong>ACK=Y+1， Seq=Z</strong></li>
            </ol>
        </li>
        <li>TCP链接建立后<strong>发送HTTP请求</strong></li>
        <li>服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序</li>
        <li>服务器检查<strong>HTTP请求头是否包含缓存验证信息</strong>如果验证缓存新鲜，返回<strong>304</strong>等对应状态码</li>
        <li>处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作</li>
        <li>服务器将<strong>响应报文通过TCP连接发送回浏览器</strong></li>
        <li>浏览器接收HTTP响应，然后根据情况选择<strong>关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下</strong>：
            <ol>
                <li>主动方发送<strong>Fin=1， Ack=Z， Seq= X</strong>报文</li>
                <li>被动方发送<strong>ACK=X+1， Seq=Z</strong>报文</li>
                <li>被动方发送<strong>Fin=1， ACK=X， Seq=Y</strong>报文</li>
                <li>主动方发送<strong>ACK=Y， Seq=X</strong>报文</li>
            </ol>
        </li>
        <li>浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同</li>
        <li>如果资源可缓存，<strong>进行缓存</strong></li>
        <li>对响应进行<strong>解码</strong>（例如gzip压缩）</li>
        <li>根据资源类型决定如何处理（假设资源为HTML文档）</li>
        <li><strong>解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本</strong>，这些操作没有严格的先后顺序，以下分别解释</li>
        <li><strong>构建DOM树</strong>：
            <ol>
                <li><strong>Tokenizing</strong>：根据HTML规范将字符流解析为标记</li>
                <li><strong>Lexing</strong>：词法分析将标记转换为对象并定义属性和规则</li>
                <li><strong>DOM construction</strong>：根据HTML标记关系将对象组成DOM树</li>
            </ol>
        </li>
        <li>解析过程中遇到图片、样式表、js文件，<strong>启动下载</strong></li>
        <li>构建<strong>CSSOM树</strong>：
            <ol>
                <li><strong>Tokenizing</strong>：字符流转换为标记流</li>
                <li><strong>Node</strong>：根据标记创建节点</li>
                <li><strong>CSSOM</strong>：节点创建CSSOM树</li>
            </ol>
        </li>
        <li><strong><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction">根据DOM树和CSSOM树构建渲染树</a></strong>:
            <ol>
                <li>从DOM树的根节点遍历所有<strong>可见节点</strong>，不可见节点包括：1）<code>script</code>,<code>meta</code>这样本身不可见的标签。2)被css隐藏的节点，如<code>display: none</code></li>
                <li>对每一个可见节点，找到恰当的CSSOM规则并应用</li>
                <li>发布可视节点的内容和计算样式</li>
            </ol>
        </li>
        <li><strong>js解析如下</strong>：
            <ol>
                <li>浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时<strong>document.readystate为loading</strong></li>
                <li>HTML解析器遇到<strong>没有async和defer的script时</strong>，将他们添加到文档中，然后执行行内或外部脚本。这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。这样就可以用document.write()把文本插入到输入流中。<strong>同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容</strong></li>
                <li>当解析器遇到设置了<strong>async</strong>属性的script时，开始下载脚本并继续解析文档。脚本会在它<strong>下载完成后尽快执行</strong>，但是<strong>解析器不会停下来等它下载</strong>。异步脚本<strong>禁止使用document.write()</strong>，它们可以访问自己script和之前的文档元素</li>
                <li>当文档完成解析，document.readState变成interactive</li>
                <li>所有<strong>defer</strong>脚本会<strong>按照在文档出现的顺序执行</strong>，延迟脚本<strong>能访问完整文档树</strong>，禁止使用document.write()</li>
                <li>浏览器<strong>在Document对象上触发DOMContentLoaded事件</strong></li>
                <li>此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，等这些<strong>内容完成载入并且所有异步脚本完成载入和执行</strong>，document.readState变为complete,window触发load事件</li>
            </ol>
        </li>
        <li><strong>显示页面</strong>（HTML解析过程中会逐步显示页面）</li>
    </ol>
    <h3>http-request报文结构是怎样的</h3>
    <ol>
        <li>首行是<strong>Request-Line</strong>包括：<strong>请求方法</strong>，<strong>请求URI</strong>，<strong>协议版本</strong>，<strong>CRLF</strong></li>
        <li>首行之后是若干行<strong>请求头</strong>，包括<strong>general-header</strong>，<strong>request-header</strong>或者<strong>entity-header</strong>，每个一行以CRLF结束</li>
        <li>请求头和消息实体之间有一个<strong>CRLF分隔</strong></li>
        <li>根据实际请求需要可能包含一个<strong>消息实体</strong> 一个请求报文例子如下：
        </li>
    </ol>
    <pre><code>GET /Protocols/rfc2616/rfc2616-sec5.html HTTP/1.1
Host: www.w3.org
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36
Referer: https://www.google.com.hk/
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh-CN,zh;q=0.8,en;q=0.6
Cookie: authorstyle=yes
If-None-Match: "2cc8-3e3073913b100"
If-Modified-Since: Wed, 01 Sep 2004 13:24:52 GMT

name=qiu&amp;age=25
</code></pre>
    <h3>HTTP response报文结构是怎样的</h3>
    <ol>
        <li>首行是状态行包括：<strong>HTTP版本，状态码，状态描述</strong>，后面跟一个CRLF</li>
        <li>首行之后是<strong>若干行响应头</strong>，包括：<strong>通用头部，响应头部，实体头部</strong></li>
        <li>响应头部和响应实体之间用<strong>一个CRLF空行</strong>分隔</li>
        <li>最后是一个可能的<strong>消息实体</strong> 响应报文例子如下：
        </li>
    </ol>
    <pre><code>HTTP/1.1 200 OK
Date: Tue, 08 Jul 2014 05:28:43 GMT
Server: Apache/2
Last-Modified: Wed, 01 Sep 2004 13:24:52 GMT
ETag: "40d7-3e3073913b100"
Accept-Ranges: bytes
Content-Length: 16599
Cache-Control: max-age=21600
Expires: Tue, 08 Jul 2014 11:28:43 GMT
P3P: policyref="http://www.w3.org/2001/05/P3P/p3p.xml"
Content-Type: text/html; charset=iso-8859-1

{"name": "qiu", "age": 25}
</code></pre>
    <h3>如何进行网站性能优化</h3>
    <ul>
        <li>
            <p>content方面</p>
            <ol>
                <li>减少HTTP请求：合并文件、CSS精灵、inline Image</li>
                <li>减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询</li>
                <li>避免重定向：多余的中间访问</li>
                <li>使Ajax可缓存</li>
                <li>非必须组件延迟加载</li>
                <li>未来所需组件预加载</li>
                <li>减少DOM元素数量</li>
                <li>将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量</li>
                <li>减少iframe数量</li>
                <li>不要404</li>
            </ol>
        </li>
        <li>
            <p>Server方面</p>
            <ol>
                <li>使用CDN</li>
                <li>添加Expires或者Cache-Control响应头</li>
                <li>对组件使用Gzip压缩</li>
                <li>配置ETag</li>
                <li>Flush Buffer Early</li>
                <li>Ajax使用GET进行请求</li>
                <li>避免空src的img标签</li>
            </ol>
        </li>
        <li>Cookie方面
            <ol>
                <li>减小cookie大小</li>
                <li>引入资源的域名不要包含cookie</li>
            </ol>
        </li>
        <li>css方面
            <ol>
                <li>将样式表放到页面顶部</li>
                <li>不使用CSS表达式</li>
                <li>使用不使用@import</li>
                <li>不使用IE的Filter</li>
            </ol>
        </li>
        <li>Javascript方面
            <ol>
                <li>将脚本放到页面底部</li>
                <li>将javascript和css从外部引入</li>
                <li>压缩javascript和css</li>
                <li>删除不需要的脚本</li>
                <li>减少DOM访问</li>
                <li>合理设计事件监听器</li>
            </ol>
        </li>
        <li>图片方面
            <ol>
                <li>优化图片：根据实际颜色需要选择色深、压缩</li>
                <li>优化css精灵</li>
                <li>不要在HTML中拉伸图片</li>
                <li>保证favicon.ico小并且可缓存</li>
            </ol>
        </li>
        <li>移动方面
            <ol>
                <li>保证组件小于25k</li>
                <li>Pack Components into a Multipart Document</li>
            </ol>
        </li>
    </ul>
    <h3>什么是渐进增强</h3>
    <p>渐进增强是指在web设计时强调可访问性、语义化HTML标签、外部样式表和脚本。保证所有人都能访问页面的基本内容和功能同时为高级浏览器和高带宽用户提供更好的用户体验。核心原则如下:</p>
    <ul>
        <li>所有浏览器都必须能访问基本内容</li>
        <li>所有浏览器都必须能使用基本功能</li>
        <li>所有内容都包含在语义化标签中</li>
        <li>通过外部CSS提供增强的布局</li>
        <li>通过非侵入式、外部javascript提供增强功能</li>
        <li>end-user web browser preferences are respected</li>
    </ul>
    <h3>http状态码及其含义</h3>
    <ul>
        <li>1XX：信息状态码
            <ul>
                <li><strong>100 Continue</strong>：客户端应当继续发送请求。这个临时相应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求万仇向客户端发送一个最终响应</li>
                <li><strong>101 Switching Protocols</strong>：服务器已经理解力客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到Upgrade消息头中定义的那些协议。</li>
            </ul>
        </li>
        <li>2XX：成功状态码
            <ul>
                <li><strong>200 OK</strong>：请求成功，请求所希望的响应头或数据体将随此响应返回</li>
                <li><strong>201 Created</strong>：</li>
                <li><strong>202 Accepted</strong>：</li>
                <li><strong>203 Non-Authoritative Information</strong>：</li>
                <li><strong>204 No Content</strong>：</li>
                <li><strong>205 Reset Content</strong>：</li>
                <li><strong>206 Partial Content</strong>：</li>
            </ul>
        </li>
        <li>3XX：重定向
            <ul>
                <li><strong>300 Multiple Choices</strong>：</li>
                <li><strong>301 Moved Permanently</strong>：</li>
                <li><strong>302 Found</strong>：</li>
                <li><strong>303 See Other</strong>：</li>
                <li><strong>304 Not Modified</strong>：</li>
                <li><strong>305 Use Proxy</strong>：</li>
                <li><strong>306 （unused）</strong>：</li>
                <li><strong>307 Temporary Redirect</strong>：</li>
            </ul>
        </li>
        <li>4XX：客户端错误
            <ul>
                <li><strong>400 Bad Request</strong>:</li>
                <li><strong>401 Unauthorized</strong>:</li>
                <li><strong>402 Payment Required</strong>:</li>
                <li><strong>403 Forbidden</strong>:</li>
                <li><strong>404 Not Found</strong>:</li>
                <li><strong>405 Method Not Allowed</strong>:</li>
                <li><strong>406 Not Acceptable</strong>:</li>
                <li><strong>407 Proxy Authentication Required</strong>:</li>
                <li><strong>408 Request Timeout</strong>:</li>
                <li><strong>409 Conflict</strong>:</li>
                <li><strong>410 Gone</strong>:</li>
                <li><strong>411 Length Required</strong>:</li>
                <li><strong>412 Precondition Failed</strong>:</li>
                <li><strong>413 Request Entity Too Large</strong>:</li>
                <li><strong>414 Request-URI Too Long</strong>:</li>
                <li><strong>415 Unsupported Media Type</strong>:</li>
                <li><strong>416 Requested Range Not Satisfiable</strong>:</li>
                <li><strong>417 Expectation Failed</strong>:</li>
            </ul>
        </li>
        <li>5XX: 服务器错误
            <ul>
                <li><strong>500 Internal Server Error</strong>:</li>
                <li><strong>501 Not Implemented</strong>:</li>
                <li><strong>502 Bad Gateway</strong>:</li>
                <li><strong>503 Service Unavailable</strong>:</li>
                <li><strong>504 Gateway Timeout</strong>:</li>
                <li><strong>505 HTTP Version Not Supported</strong>:</li>
            </ul>
        </li>
    </ul>
    <h3>css选择器有哪些</h3>
    <ol>
        <li><em>**通用选择器</em><em>：选择所有元素，</em><em>不参与计算优先级</em>*，兼容性IE6+</li>
        <li><strong>#X id选择器</strong>：选择id值为X的元素，兼容性：IE6+</li>
        <li><strong>.X 类选择器</strong>： 选择class包含X的元素，兼容性：IE6+</li>
        <li><strong>X Y后代选择器</strong>： 选择满足X选择器的后代节点中满足Y选择器的元素，兼容性：IE6+</li>
        <li><strong>X 元素选择器</strong>： 选择标所有签为X的元素，兼容性：IE6+</li>
        <li><strong>:link，：visited，：focus，：hover，：active链接状态</strong>： 选择特定状态的链接元素，顺序LoVe HAte，兼容性: IE4+</li>
        <li><strong>X + Y直接兄弟选择器</strong>：在<strong>X之后第一个兄弟节点</strong>中选择满足Y选择器的元素，兼容性： IE7+</li>
        <li><strong>X &gt; Y子选择器</strong>： 选择X的子元素中满足Y选择器的元素，兼容性： IE7+</li>
        <li><strong>X ~ Y兄弟</strong>： 选择<strong>X之后所有兄弟节点</strong>中满足Y选择器的元素，兼容性： IE7+</li>
        <li><strong>[attr]</strong>：选择所有设置了attr属性的元素，兼容性IE7+</li>
        <li><strong>[attr=value]</strong>：选择属性值刚好为value的元素</li>
        <li><strong>[attr~=value]</strong>：选择属性值为空白符分隔，其中一个的值刚好是value的元素</li>
        <li><strong>[attr|=value]</strong>：选择属性值刚好为value或者value-开头的元素</li>
        <li><strong>[attr^=value]</strong>：选择属性值以value开头的元素</li>
        <li><strong>[attr$=value]</strong>：选择属性值以value结尾的元素</li>
        <li><strong>[attr*=value]</strong>：选择属性值中包含value的元素</li>
        <li><strong>[:checked]</strong>：选择单选框，复选框，下拉框中选中状态下的元素，兼容性：IE9+</li>
        <li><strong>X:after, X::after</strong>：after伪元素，选择元素虚拟子元素（元素的最后一个子元素），CSS3中::表示伪元素。兼容性:after为IE8+，::after为IE9+</li>
        <li><strong>:hover</strong>：鼠标移入状态的元素，兼容性a标签IE4+， 所有元素IE7+</li>
        <li><strong>:not(selector)</strong>：选择不符合selector的元素。<strong>不参与计算优先级</strong>，兼容性：IE9+</li>
        <li><strong>::first-letter</strong>：伪元素，选择块元素第一行的第一个字母，兼容性IE5.5+</li>
        <li><strong>::first-line</strong>：伪元素，选择块元素的第一行，兼容性IE5.5+</li>
        <li><strong>:nth-child(an + b)</strong>：伪类，选择前面有an + b - 1个兄弟节点的元素，其中n &gt;= 0， 兼容性IE9+</li>
        <li><strong>:nth-last-child(an + b)</strong>：伪类，选择后面有an + b - 1个兄弟节点的元素 其中n &gt;= 0，兼容性IE9+</li>
        <li><strong>X:nth-of-type(an+b)</strong>：伪类，X为选择器，<strong>解析得到元素标签</strong>，选择<strong>前面</strong>有an + b - 1个<strong>相同标签</strong>兄弟节点的元素。兼容性IE9+</li>
        <li><strong>X:nth-last-of-type(an+b)</strong>：伪类，X为选择器，解析得到元素标签，选择<strong>后面</strong>有an+b-1个相同<strong>标签</strong>兄弟节点的元素。兼容性IE9+</li>
        <li><strong>X:first-child</strong>：伪类，选择满足X选择器的元素，且这个元素是其父节点的第一个子元素。兼容性IE7+</li>
        <li><strong>X:last-child</strong>：伪类，选择满足X选择器的元素，且这个元素是其父节点的最后一个子元素。兼容性IE9+</li>
        <li><strong>X:only-child</strong>：伪类，选择满足X选择器的元素，且这个元素是其父元素的唯一子元素。兼容性IE9+</li>
        <li><strong>X:only-of-type</strong>：伪类，选择X选择的元素，<strong>解析得到元素标签</strong>，如果该元素没有相同类型的兄弟节点时选中它。兼容性IE9+</li>
        <li><strong>X:first-of-type</strong>：伪类，选择X选择的元素，<strong>解析得到元素标签</strong>，如果该元素 是此此类型元素的第一个兄弟。选中它。兼容性IE9+
        </li>
    </ol>
    <h3>css-hack原理及常用hack</h3>
    <p>原理：利用<strong>不同浏览器对CSS的支持和解析结果不一样</strong>编写针对特定浏览器样式。常见的hack有1）属性hack。2）选择器hack。3）IE条件注释</p>
    <ul>
        <li>IE条件注释：适用于[IE5, IE9]常见格式如下</li>
    </ul>
    <pre><code>&lt;!--[if IE 6]&gt;
Special instructions for IE 6 here
&lt;![endif]--&gt;
</code></pre>
    <ul>
        <li>选择器hack：不同浏览器对选择器的支持不一样</li>
    </ul>
    <pre><code>/***** Selector Hacks ******/

/* IE6 and below */
* html #uno  { color: red }

/* IE7 */
*:first-child+html #dos { color: red }

/* IE7, FF, Saf, Opera  */
html&gt;body #tres { color: red }

/* IE8, FF, Saf, Opera (Everything but IE 6,7) */
html&gt;/**/body #cuatro { color: red }

/* Opera 9.27 and below, safari 2 */
html:first-child #cinco { color: red }

/* Safari 2-3 */
html[xmlns*=""] body:last-child #seis { color: red }

/* safari 3+, chrome 1+, opera9+, ff 3.5+ */
body:nth-of-type(1) #siete { color: red }

/* safari 3+, chrome 1+, opera9+, ff 3.5+ */
body:first-of-type #ocho {  color: red }

/* saf3+, chrome1+ */
@media screen and (-webkit-min-device-pixel-ratio:0) {
 #diez  { color: red  }
}

/* iPhone / mobile webkit */
@media screen and (max-device-width: 480px) {
 #veintiseis { color: red  }
}

/* Safari 2 - 3.1 */
html[xmlns*=""]:root #trece  { color: red  }

/* Safari 2 - 3.1, Opera 9.25 */
*|html[xmlns*=""] #catorce { color: red  }

/* Everything but IE6-8 */
:root *&gt; #quince { color: red  }

/* IE7 */
*+html #dieciocho {  color: red }

/* Firefox only. 1+ */
#veinticuatro,  x:-moz-any-link  { color: red }

/* Firefox 3.0+ */
#veinticinco,  x:-moz-any-link, x:default  { color: red  }
</code></pre>
    <ul>
        <li>属性hack：不同浏览器解析bug或方法</li>
    </ul>
    <pre><code>/* IE6 */
#once { _color: blue }

/* IE6, IE7 */
#doce { *color: blue; /* or #color: blue */ }

/* Everything but IE6 */
#diecisiete { color/**/: blue }

/* IE6, IE7, IE8 */
#diecinueve { color: blue\9; }

/* IE7, IE8 */
#veinte { color/*\**/: blue\9; }

/* IE6, IE7 -- acts as an !important */
#veintesiete { color: blue !ie; } /* string after ! can be anything */
</code></pre>
    <h3>link与import的区别</h3>
    <ol>
        <li><code>link</code>是HTML方式， <code>@import</code>是CSS方式</li>
        <li><code>link</code>最大限度支持并行下载，<code>@import</code>过多嵌套导致串行下载，出现<a href="http://www.bluerobot.com/web/css/fouc.asp/">FOUC</a></li>
        <li><code>link</code>可以通过<code>rel="alternate stylesheet"</code>指定候选样式</li>
        <li>浏览器对<code>link</code>支持早于<code>@import</code>，可以使用<code>@import</code>对老浏览器隐藏样式</li>
        <li><code>@import</code>必须在样式规则之前，可以在css文件中引用其他文件</li>
        <li>总体来说：<strong><a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/">link优于@import</a></strong></li>
    </ol>
    <h3>display-block和display-inline的区别</h3>
    <p><code>block</code>元素特点：</p>
    <p>1.处于常规流中时，如果<code>width</code>没有设置，会自动填充满父容器 2.可以应用
        <code>margin/padding</code> 3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素 4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间） 5.忽略
        <code>vertical-align</code></p>
    <p><code>inline</code>元素特点</p>
    <p>1.水平方向上根据<code>direction</code>依次布局 2.不会在元素前后进行换行 3.受
        <code>white-space</code>控制 4.
        <code>margin/padding</code>在竖直方向上无效，水平方向上有效 5.
        <code>width/height</code>属性对非替换行内元素无效，宽度由元素内容决定 6.非替换行内元素的行框高由
        <code>line-height</code>确定，替换行内元素的行框高由<code>height</code>,<code>margin</code>,<code>padding</code>,<code>border</code>决定 6.浮动或绝对定位时会转换为
        <code>block</code> 7.
        <code>vertical-align</code>属性生效</p>
    <h3>ie6浏览器有哪些常见的bug缺陷或者与标准不一致的地方如何解决</h3>
    <ul>
        <li>IE6不支持min-height，解决办法使用css hack：</li>
    </ul>
    <pre><code>.target {
    min-height: 100px;
    height: auto !important;
    height: 100px;   // IE6下内容高度超过会自动扩展高度
}
</code></pre>
    <ul>
        <li>
            <p><code>ol</code>内<code>li</code>的序号全为1，不递增。解决方法：为li设置样式<code>display: list-item;</code></p>
        </li>
        <li>
            <p>未定位父元素<code>overflow: auto;</code>，包含<code>position: relative;</code>子元素，子元素高于父元素时会溢出。解决办法：1）子元素去掉<code>position: relative;</code>; 2）不能为子元素去掉定位时，父元素<code>position: relative;</code></p>
        </li>
    </ul>
    <pre><code>&lt;style type="text/css"&gt;
.outer {
    width: 215px;
    height: 100px;
    border: 1px solid red;
    overflow: auto;
    position: relative;  /* 修复bug */
}
.inner {
    width: 100px;
    height: 200px;
    background-color: purple;
    position: relative;
}
&lt;/style&gt;

&lt;div class="outer"&gt;
    &lt;div class="inner"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
    <ul>
        <li>IE6只支持<code>a</code>标签的<code>:hover</code>伪类，解决方法：使用js为元素监听mouseenter，mouseleave事件，添加类实现效果：</li>
    </ul>
    <pre><code>&lt;style type="text/css"&gt;
.p:hover,
.hover {
    background: purple;
}
&lt;/style&gt;

&lt;p class="p" id="target"&gt;aaaa bbbbb&lt;span&gt;DDDDDDDDDDDd&lt;/span&gt; aaaa lkjlkjdf j&lt;/p&gt;

&lt;script type="text/javascript"&gt;
function addClass(elem, cls) {
    if (elem.className) {
        elem.className += ' ' + cls;
    } else {
        elem.className = cls;
    }
}
function removeClass(elem, cls) {
    var className = ' ' + elem.className + ' ';
    var reg = new RegExp(' +' + cls + ' +', 'g');
    elem.className = className.replace(reg, ' ').replace(/^ +| +$/, '');
}

var target = document.getElementById('target');
if (target.attachEvent) {
    target.attachEvent('onmouseenter', function () {
        addClass(target, 'hover');
    });
    target.attachEvent('onmouseleave', function () {
        removeClass(target, 'hover');
    })
}
&lt;/script&gt;
</code></pre>
    <ul>
        <li>IE5-8不支持<code>opacity</code>，解决办法：</li>
    </ul>
    <pre><code>.opacity {
    opacity: 0.4
    filter: alpha(opacity=60); /* for IE5-7 */
    -ms-filter: "progid:DXImageTransform.Microsoft.Alpha(Opacity=60)"; /* for IE 8*/
}
</code></pre>
    <ul>
        <li>IE6在设置<code>height</code>小于<code>font-size</code>时高度值为<code>font-size</code>，解决办法：<code>font-size: 0;</code></li>
        <li>IE6不支持PNG透明背景，解决办法: <strong>IE6下使用gif图片</strong></li>
        <li>IE6-7不支持<code>display: inline-block</code>解决办法：设置inline并触发hasLayout</li>
    </ul>
    <pre><code>    display: inline-block;
    *display: inline;
    *zoom: 1;
</code></pre>
    <ul>
        <li>IE6下浮动元素在浮动方向上与父元素边界接触元素的外边距会加倍。解决办法： 1）使用padding控制间距。 2）浮动元素
            <code>display: inline;</code>这样解决问题且无任何副作用：css标准规定浮动元素display:inline会自动调整为block</li>
        <li>通过为块级元素设置宽度和左右margin为auto时，IE6不能实现水平居中，解决方法：为父元素设置<code>text-align: center;</code></li>
    </ul>
    <h3>容器包含若干浮动元素时如何清理包含浮动</h3>
    <ol>
        <li>容器元素闭合标签前添加额外元素并设置<code>clear: both</code></li>
        <li>父元素触发块级格式化上下文(见块级可视化上下文部分)</li>
        <li>设置容器元素伪元素进行清理<a href="http://nicolasgallagher.com/micro-clearfix-hack/">推荐的清理浮动方法</a></li>
    </ol>
    <pre><code>/**
* 在标准浏览器下使用
* 1 content内容为空格用于修复opera下文档中出现
*   contenteditable属性时在清理浮动元素上下的空白
* 2 使用display使用table而不是block：可以防止容器和
*   子元素top-margin折叠,这样能使清理效果与BFC，IE6/7
*   zoom: 1;一致
**/

.clearfix:before,
.clearfix:after {
    content: " "; /* 1 */
    display: table; /* 2 */
}

.clearfix:after {
    clear: both;
}

/**
* IE 6/7下使用
* 通过触发hasLayout实现包含浮动
**/
.clearfix {
    *zoom: 1;
}
</code></pre>
    <h3>xmlhttprequest通用属性和方法</h3>
    <ol>
        <li><code>readyState</code>:表示请求状态的整数，取值：
            <ul>
                <li>UNSENT（0）：对象已创建</li>
                <li>OPENED（1）：open()成功调用，在这个状态下，可以为xhr设置请求头，或者使用send()发送请求</li>
                <li>HEADERS_RECEIVED(2)：所有重定向已经自动完成访问，并且最终响应的HTTP头已经收到</li>
                <li>LOADING(3)：响应体正在接收</li>
                <li>DONE(4)：数据传输完成或者传输产生错误</li>
            </ul>
        </li>
        <li><code>onreadystatechange</code>：readyState改变时调用的函数</li>
        <li><code>status</code>：服务器返回的HTTP状态码（如，200， 404）</li>
        <li><code>statusText</code>:服务器返回的HTTP状态信息（如，OK，No Content）</li>
        <li><code>responseText</code>:作为字符串形式的来自服务器的完整响应</li>
        <li><code>responseXML</code>: Document对象，表示服务器的响应解析成的XML文档</li>
        <li><code>abort()</code>:取消异步HTTP请求</li>
        <li><code>getAllResponseHeaders()</code>: 返回一个字符串，包含响应中服务器发送的全部HTTP报头。每个报头都是一个用冒号分隔开的名/值对，并且使用一个回车/换行来分隔报头行</li>
        <li><code>getResponseHeader(headerName)</code>:返回headName对应的报头值</li>
        <li><code>open(method, url, asynchronous [, user, password])</code>:初始化准备发送到服务器上的请求。method是HTTP方法，不区分大小写；url是请求发送的相对或绝对URL；asynchronous表示请求是否异步；user和password提供身份验证</li>
        <li><code>setRequestHeader(name, value)</code>:设置HTTP报头</li>
        <li><code>send(body)</code>:对服务器请求进行初始化。参数body包含请求的主体部分，对于POST请求为键值对字符串；对于GET请求，为null</li>
    </ol>
    <h3>javascript有哪几种数据类型</h3>
    <p>六种基本数据类型</p>
    <ul>
        <li>undefined</li>
        <li>null</li>
        <li>string</li>
        <li>boolean</li>
        <li>number</li>
        <li><a href="https://developer.mozilla.org/en-US/docs/Glossary/Symbol">symbol</a>(ES6)</li>
    </ul>
    <p>一种引用类型</p>
    <ul>
        <li>Object</li>
    </ul>
    <h3>函数内部arguments变量有哪些特性有哪些属性如何将它转换为数组</h3>
    <ul>
        <li>arguments所有函数中都包含的一个局部变量，是一个类数组对象，对应函数调用时的实参。如果函数定义同名参数会在调用时覆盖默认对象</li>
        <li>arguments[index]分别对应函数调用时的实参，并且通过arguments修改实参时会同时修改实参</li>
        <li>arguments.length为实参的个数（Function.length表示形参长度）</li>
        <li>arguments.callee为当前正在执行的函数本身，使用这个属性进行递归调用时需注意this的变化</li>
        <li>arguments.caller为调用当前函数的函数（已被遗弃）</li>
        <li>转换为数组：<code>var args = Array.prototype.slice.call(arguments, 0);</code></li>
    </ul>
    <h3>评价一下三种方法实现继承的优缺点并改进</h3>
    <pre><code>function Shape() {}

function Rect() {}

// 方法1
Rect.prototype = new Shape();

// 方法2
Rect.prototype = Shape.prototype;

// 方法3
Rect.prototype = Object.create(Shape.prototype);

Rect.prototype.area = function () {
  // do something
};
</code></pre>

<p>方法1：</p>

<ol>
<li>优点：正确设置原型链实现继承</li>
<li>优点：父类实例属性得到继承，原型链查找效率提高，也能为一些属性提供合理的默认值</li>
<li>缺点：父类实例属性为引用类型时，不恰当地修改会导致所有子类被修改</li>
<li>缺点：创建父类实例作为子类原型时，可能无法确定构造函数需要的合理参数，这样提供的参数继承给子类没有实际意义，当子类需要这些参数时应该在构造函数中进行初始化和设置</li>
<li>总结：继承应该是继承方法而不是属性，为子类设置父类实例属性应该是通过在子类构造函数中调用父类构造函数进行初始化</li>
</ol>

<p>方法2：</p>

<ol>
<li>优点：正确设置原型链实现继承</li>
<li>缺点：父类构造函数原型与子类相同。修改子类原型添加方法会修改父类</li>
</ol>

<p>方法3：</p>

<ol>
<li>优点：正确设置原型链且避免方法1.2中的缺点</li>
<li>缺点：ES5方法需要注意兼容性</li>
</ol>

<p>改进：</p>

<ol>
<li>所有三种方法应该在子类构造函数中调用父类构造函数实现实例属性初始化</li>
</ol>

<pre><code>function Rect() {
    Shape.call(this);
}
</code></pre>
<ol>

<li>用新创建的对象替代子类默认原型，设置<code>Rect.prototype.constructor = Rect;</code>保证一致性</li>
<li>第三种方法的polyfill：</li>
</ol>

<pre><code>function create(obj) {
    if (Object.create) {
        return Object.create(obj);
    }

    function f() {};
    f.prototype = obj;
    return new f();
}
</code></pre>
</body>

</html>
